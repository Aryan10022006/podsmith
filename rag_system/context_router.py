"""Context Router for Audio RAG SystemIntelligent routing system that analyzes queries to determine the bestdata sources, search strategies, and response approaches for differenttypes of queries about audio analysis data."""
import refrom typing import List, Dict, Any, Setfrom datetime import datetimeimport jsonclass ContextRouter:    """    Intelligent query routing system that analyzes queries to determine    the best data sources, search strategies, and response approaches.    """        def __init__(self):        """Initialize the context router with query patterns and preferences."""        # Query focus patterns        self.query_patterns = {            'time_focus': [                r'\b(?:at|around|during|between|from|after|before)\s+(?:\d+|\w+)\b',                r'\b(?:minute|second|hour|timestamp|time)\b',                r'\b(?:beginning|start|end|middle|later|earlier)\b'            ],            'speaker_focus': [                r'\b(?:who|speaker|person|said|spoke|mentioned)\b',                r'\b(?:john|mary|sarah|mike|speaker\s*\d+)\b'            ],            'emotion_focus': [                r'\b(?:emotion|feeling|mood|sentiment|tone)\b',                r'\b(?:happy|sad|angry|excited|calm|frustrated|positive|negative)\b',                r'\b(?:emotional|emotionally)\b'            ],            'topic_focus': [                r'\b(?:topic|subject|theme|about|regarding|concerning)\b',                r'\b(?:discuss|discussion|talked|conversation)\b'            ],            'summary_focus': [                r'\b(?:summary|summarize|overview|key\s+points|main\s+ideas)\b',                r'\b(?:what\s+happened|tell\s+me\s+about|explain)\b'            ],            'search_focus': [                r'\b(?:find|search|look\s+for|show\s+me)\b',                r'\b(?:where|when|how)\b'            ]        }                # Enhanced emotion keywords with intensity levels        self.emotion_keywords = {            'joy': {                'high': ['ecstatic', 'elated', 'thrilled', 'overjoyed', 'euphoric'],                'medium': ['happy', 'excited', 'pleased', 'cheerful', 'delighted'],                'low': ['content', 'satisfied', 'glad', 'upbeat']            },            'anger': {                'high': ['furious', 'enraged', 'livid', 'irate'],                'medium': ['angry', 'mad', 'frustrated', 'annoyed', 'irritated'],                'low': ['displeased', 'bothered', 'irked']            },            'sadness': {                'high': ['devastated', 'heartbroken', 'despairing'],                'medium': ['sad', 'depressed', 'melancholy', 'sorrowful'],                'low': ['disappointed', 'down', 'blue', 'glum']            },            'fear': {                'high': ['terrified', 'horrified', 'panicked'],                'medium': ['afraid', 'scared', 'fearful', 'anxious'],                'low': ['nervous', 'uneasy', 'concerned']            },            'surprise': {                'high': ['shocked', 'astonished', 'amazed', 'stunned'],                'medium': ['surprised', 'unexpected', 'startled'],                'low': ['curious', 'intrigued', 'wondering']            },            'disgust': {                'high': ['revolted', 'repulsed', 'sickened'],                'medium': ['disgusted', 'repelled', 'offended'],                'low': ['displeased', 'uncomfortable']            },            'neutral': {                'high': ['completely neutral', 'totally objective'],                'medium': ['neutral', 'calm', 'composed'],                'low': ['indifferent', 'detached', 'objective']            }        }                # Domain detection patterns        self.domain_patterns = {            'business': ['meeting', 'project', 'deadline', 'budget', 'revenue', 'client', 'strategy', 'market', 'sales', 'finance'],            'technology': ['software', 'AI', 'machine learning', 'algorithm', 'database', 'coding', 'programming', 'development', 'tech', 'digital'],            'education': ['learning', 'teaching', 'student', 'course', 'lesson', 'education', 'training', 'academic', 'study', 'knowledge'],            'healthcare': ['medical', 'health', 'patient', 'doctor', 'treatment', 'diagnosis', 'therapy', 'medicine', 'clinical', 'hospital'],            'science': ['research', 'experiment', 'data', 'analysis', 'hypothesis', 'theory', 'scientific', 'study', 'findings', 'results'],            'social': ['family', 'friends', 'social', 'personal', 'relationship', 'community', 'gathering', 'event', 'celebration', 'party']        }                # Content type preferences based on query focus        self.content_preferences = {            'time_focus': ['enriched_segment', 'transcription'],            'speaker_focus': ['diarization', 'enriched_segment'],            'emotion_focus': ['emotion_detection', 'enriched_segment'],            'topic_focus': ['semantic_segmentation', 'summary_block', 'key_point'],            'summary_focus': ['summary_block', 'overall_summary', 'highlight'],            'search_focus': ['enriched_segment', 'transcription']        }                # Default content type priority        self.default_content_types = [            'enriched_segment', 'summary_block', 'key_point',             'highlight', 'overall_summary', 'transcription'        ]        def route_query(self, query: str, available_data_types: List[str]) -> Dict[str, Any]:        """        Route a query to determine the best data sources and filters.                Args:            query: Natural language query            available_data_types: List of available data types                    Returns:            Routing configuration with data types, filters, and strategy        """        query_lower = query.lower()                # Detect query focuses        focuses = self._detect_query_focuses(query_lower)                # Detect domain/theme        domain = self._detect_domain(query_lower)                # Extract specific entities        entities = self._extract_entities(query)                # Enhanced emotion analysis        emotion_analysis = self._analyze_emotional_intent(query_lower)                # Determine content type priorities        content_types = self._determine_content_types(focuses, available_data_types, domain)                # Build filters with emotion and domain awareness        filters = self._build_filters(entities, focuses, domain, emotion_analysis)                # Determine search strategy        strategy = self._determine_strategy(focuses, entities, domain, emotion_analysis)                routing_config = {            'content_types': content_types,            'filters': filters,            'strategy': strategy,            'focuses': focuses,            'domain': domain,            'emotion_analysis': emotion_analysis,            'entities': entities,            'query_complexity': self._assess_complexity(query, focuses, entities, domain),            'routing_confidence': self._calculate_confidence(entities, focuses, domain, emotion_analysis)        }                return routing_config        def _detect_query_focuses(self, query_lower: str) -> List[str]:        """Detect what the query is focusing on."""        focuses = []                for focus_type, patterns in self.query_patterns.items():            for pattern in patterns:                if re.search(pattern, query_lower, re.IGNORECASE):                    if focus_type not in focuses:                        focuses.append(focus_type)                    break                # If no specific focus detected, assume search focus        if not focuses:            focuses.append('search_focus')                return focuses        def _detect_domain(self, query_lower: str) -> str:        """Detect the domain/theme of the query."""        domain_scores = {}                for domain, patterns in self.domain_patterns.items():            score = 0            for pattern in patterns:                if pattern.lower() in query_lower:                    score += 1            domain_scores[domain] = score                if domain_scores and max(domain_scores.values()) > 0:            return max(domain_scores.items(), key=lambda x: x[1])[0]        else:            return 'general'        def _analyze_emotional_intent(self, query_lower: str) -> Dict[str, Any]:        """Analyze the emotional intent of the query."""        emotion_analysis = {            'primary_emotion': 'neutral',            'intensity': 'low',            'emotional_keywords': [],            'seeking_emotions': [],            'confidence': 0.5        }                found_emotions = {}                # Check for emotion keywords with intensity        for emotion_category, intensity_levels in self.emotion_keywords.items():            for intensity, keywords in intensity_levels.items():                for keyword in keywords:                    if keyword in query_lower:                        if emotion_category not in found_emotions:                            found_emotions[emotion_category] = []                        found_emotions[emotion_category].append((keyword, intensity))                if found_emotions:            # Find the most prominent emotion            emotion_counts = {emotion: len(keywords) for emotion, keywords in found_emotions.items()}            primary_emotion = max(emotion_counts.items(), key=lambda x: x[1])[0]                        # Determine intensity based on highest intensity keyword found            intensities = [intensity for _, intensity in found_emotions[primary_emotion]]            if 'high' in intensities:                intensity = 'high'            elif 'medium' in intensities:                intensity = 'medium'            else:                intensity = 'low'                        emotion_analysis.update({                'primary_emotion': primary_emotion,                'intensity': intensity,                'emotional_keywords': [kw for kw, _ in found_emotions[primary_emotion]],                'seeking_emotions': list(found_emotions.keys()),                'confidence': min(0.9, 0.5 + len(found_emotions) * 0.2)            })                return emotion_analysis        def _extract_entities(self, query: str) -> Dict[str, Any]:        """Extract entities from the query."""        entities = {            'time': self._extract_time_references(query),            'speakers': self._extract_speakers(query),            'emotions': self._extract_emotion_keywords(query),            'topics': self._extract_topic_keywords(query)        }        return entities        def _extract_time_references(self, query: str) -> Dict[str, Any]:        """Extract time-related information from query."""        time_info = {}        query_lower = query.lower()                # Look for specific timestamps        timestamp_patterns = [            r'(\d+):(\d+)',  # MM:SS format            r'(\d+)\s*(?:minutes?|mins?)',  # X minutes            r'(\d+)\s*(?:seconds?|secs?)',  # X seconds            r'at\s+(\d+)',  # at X        ]                for pattern in timestamp_patterns:            matches = re.findall(pattern, query_lower)            if matches:                time_info['matches'] = matches                break                # Look for relative time references        relative_patterns = ['beginning', 'start', 'end', 'middle', 'later', 'earlier']        for pattern in relative_patterns:            if pattern in query_lower:                time_info['relative'] = pattern                break                return time_info        def _extract_speakers(self, query: str) -> List[str]:        """Extract speaker references from query."""        speakers = []        query_lower = query.lower()                # Common speaker patterns        speaker_patterns = [            r'\b(john|jane|mike|sarah|mary|bob|alice|charlie|david|emma)\b',            r'\bspeaker\s*(\d+)\b',            r'\b(presenter|moderator|host|guest)\b'        ]                for pattern in speaker_patterns:            matches = re.findall(pattern, query_lower, re.IGNORECASE)            speakers.extend(matches)                return list(set(speakers))  # Remove duplicates        def _extract_emotion_keywords(self, query: str) -> Dict[str, List[str]]:        """Extract emotion-related keywords from query."""        emotions = {}        query_lower = query.lower()                for emotion_category, intensity_levels in self.emotion_keywords.items():            found_emotions = []            # Check all intensity levels for this emotion category            for intensity, keywords in intensity_levels.items():                for keyword in keywords:                    if keyword in query_lower:                        found_emotions.append(keyword)                        if found_emotions:                emotions[emotion_category] = found_emotions                return emotions        def _extract_topic_keywords(self, query: str) -> List[str]:        """Extract potential topic keywords from query."""        # Remove common query words        stop_words = {            'what', 'when', 'where', 'who', 'how', 'why', 'was', 'were', 'is', 'are',            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',            'with', 'by', 'about', 'during', 'tell', 'me', 'show', 'find', 'search'        }                words = re.findall(r'\b[a-zA-Z]{3,}\b', query.lower())        topics = [word for word in words if word not in stop_words]                return topics[:10]  # Limit to 10 keywords        def _determine_content_types(self, focuses: List[str], available_types: List[str], domain: str = 'general') -> List[str]:        """Determine which content types to prioritize based on focus and domain."""        preferred_types = []                # Get preferences based on focuses        for focus in focuses:            if focus in self.content_preferences:                for content_type in self.content_preferences[focus]:                    if content_type in available_types and content_type not in preferred_types:                        preferred_types.append(content_type)                # Domain-specific preferences        if domain == 'business':            priority_types = ['summary_block', 'key_point', 'highlight']        elif domain == 'technology':            priority_types = ['enriched_segment', 'semantic_segmentation']        elif domain == 'education':            priority_types = ['key_point', 'summary_block', 'overall_summary']        else:            priority_types = self.default_content_types                # Add domain-specific priorities        for content_type in priority_types:            if content_type in available_types and content_type not in preferred_types:                preferred_types.insert(0, content_type)                # Add any remaining available types        for content_type in available_types:            if content_type not in preferred_types:                preferred_types.append(content_type)                return preferred_types        def _build_filters(self, entities: Dict[str, Any], focuses: List[str], domain: str, emotion_analysis: Dict[str, Any]) -> Dict[str, Any]:        """Build search filters based on extracted entities, domain, and emotions."""        filters = {}                # Time-based filters        if entities['time']:            time_refs = entities['time']                        if 'timestamp' in time_refs:                timestamp = time_refs['timestamp']                filters['min_timestamp'] = max(0, timestamp - 30)                filters['max_timestamp'] = timestamp + 30            elif 'seconds' in time_refs:                filters['min_timestamp'] = time_refs['seconds']            elif 'range' in time_refs:                start, end = time_refs['range']                filters['min_timestamp'] = start                filters['max_timestamp'] = end            elif 'relative' in time_refs:                filters['time_relative'] = time_refs['relative']                # Speaker filters        if entities['speakers']:            filters['speaker'] = entities['speakers'][0]                # Emotion filters with intensity awareness        if emotion_analysis['primary_emotion'] != 'neutral':            filters['emotion'] = emotion_analysis['primary_emotion']            filters['emotion_intensity'] = emotion_analysis['intensity']                        # If seeking specific emotions, filter for those            if emotion_analysis['seeking_emotions']:                filters['seeking_emotions'] = emotion_analysis['seeking_emotions']                # Domain filters        if domain != 'general':            filters['domain'] = domain            filters['theme'] = domain                # Content type importance based on query        if 'summary_focus' in focuses:            filters['importance'] = 'high'        elif 'emotion_focus' in focuses:            filters['emotion_confidence'] = 0.6                return filters        def _determine_strategy(self, focuses: List[str], entities: Dict[str, Any], domain: str, emotion_analysis: Dict[str, Any]) -> Dict[str, Any]:        """Determine the search strategy based on comprehensive query analysis."""        strategy = {            'search_type': 'semantic',            'ranking_factors': ['similarity', 'confidence'],            'context_window': 3,            'max_results_per_type': 10,            'emotion_weighting': 1.0,            'domain_boost': 1.0        }                # Adjust strategy based on focuses        if 'summary_focus' in focuses:            strategy.update({                'search_type': 'summary_centric',                'ranking_factors': ['importance', 'coverage', 'similarity'],                'context_window': 1,                'max_results_per_type': 5            })        elif 'emotion_focus' in focuses:            strategy.update({                'search_type': 'emotion_aware',                'ranking_factors': ['emotion_match', 'intensity', 'similarity'],                'context_window': 3,                'emotion_weighting': 2.0            })        elif 'time_focus' in focuses:            strategy.update({                'search_type': 'temporal',                'ranking_factors': ['time_relevance', 'similarity'],                'context_window': 5            })                # Domain-specific adjustments        if domain in ['business', 'technology']:            strategy['max_results_per_type'] = 15        elif domain == 'education':            strategy['ranking_factors'].insert(0, 'educational_value')                # Emotion-specific adjustments        if emotion_analysis['intensity'] == 'high':            strategy['emotion_weighting'] = 2.5            strategy['context_window'] = max(strategy['context_window'], 4)                return strategy        def _assess_complexity(self, query: str, focuses: List[str], entities: Dict[str, Any], domain: str) -> str:        """Assess the complexity of the query including domain and emotional factors."""        complexity_score = 0                # Base complexity from query length        word_count = len(query.split())        if word_count > 15:            complexity_score += 2        elif word_count > 8:            complexity_score += 1                # Complexity from multiple focuses        complexity_score += len(focuses)                # Complexity from entities        if entities['time']:            complexity_score += 1        if entities['speakers']:            complexity_score += 1        if entities['emotions']:            complexity_score += 1        if len(entities['topics']) > 3:            complexity_score += 1                # Domain complexity        if domain in ['technology', 'business', 'science']:            complexity_score += 1                # Multiple emotion seeking        if len(entities.get('emotions', {})) > 1:            complexity_score += 1                # Determine complexity level        if complexity_score <= 2:            return 'simple'        elif complexity_score <= 6:            return 'moderate'        else:            return 'complex'        def _calculate_confidence(self, entities: Dict[str, Any], focuses: List[str], domain: str, emotion_analysis: Dict[str, Any]) -> float:        """Calculate confidence in the routing decision."""        confidence = 0.5  # Base confidence                # Increase confidence based on entity detection        if entities['topics']:            confidence += 0.1 * min(len(entities['topics']), 3) / 3        if entities['time']:            confidence += 0.1        if entities['speakers']:            confidence += 0.1                # Increase confidence based on clear focuses        confidence += 0.1 * min(len(focuses), 2) / 2                # Domain detection confidence        if domain != 'general':            confidence += 0.15                # Emotion analysis confidence        if emotion_analysis['confidence'] > 0.7:            confidence += 0.1        elif emotion_analysis['confidence'] > 0.5:            confidence += 0.05                return min(confidence, 1.0)